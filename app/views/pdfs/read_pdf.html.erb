<h4 class="">Read PDF</h4>

<%= link_to "Home", pdfs_path %>
<button onclick="nextPage()"> Next </button>
<button> <%= link_to 'Refresh', pdf_read_pdf_path(@pdf) %> </button>

<div class="">
  <div id="pageContainer" class="pdfViewer singlePageView dropzone nopadding" style="background-color:transparent">
    <canvas id="the-canvas" style=""></canvas>
  </div>
</div>

<!-- Below the pdf base 64 rapresentation -->
<input id="pdfBase64" type="hidden" value="<%= @pdf_attachment %>">
<input id="pdfId" type="hidden" value="<%= @pdf.id %>">
<input id="currentPage" type="hidden" value="<%= @pdf.current_page %>">

<script>
    var pdfSection = $('#pdfBase64')
    var currentPage = parseInt($('#currentPage').val())

    if(pdfSection.length > 0 ) {
        var pdfData = atob(pdfSection.val());
        var universalPageCounter = currentPage;

        pdfjsLib.GlobalWorkerOptions.workerSrc =
            'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.0.943/pdf.worker.min.js';

        var loadingTask = pdfjsLib.getDocument({data: pdfData});
        loadingTask.promise.then(function (pdf) {
            pdf.getPage(currentPage).then(function (page) {
                var scale = 1.0;
                var viewport = page.getViewport(scale);
                var canvas = document.getElementById('the-canvas');
                var context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                var renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                page.render(renderContext).then(function () {
                    $(document).trigger("pagerendered");
                    return page.getTextContent();
                }, function () {
                    alert('Error loading pdf. Try again or contact support')
                })
            })
        })

        function nextPage(){
            var loadingTask = pdfjsLib.getDocument({data: pdfData});
            loadingTask.promise.then(function (pdf) {
                if (universalPageCounter < pdf.numPages) {
                    universalPageCounter += 1;
                    pdf.getPage(universalPageCounter).then(function (page) {
                        loadPage(page)
                    });
                    savePage(false);
                }
            });
        }

        function loadPage(page) {
            var scale = 1.0;
            var viewport = page.getViewport(scale);
            var canvas = document.getElementById('the-canvas');
            var context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            var renderContext = {
                canvasContext: context,
                viewport: viewport
            };
            page.render(renderContext).then(function () {
                $(document).trigger("pagerendered");
                return page.getTextContent();
            }, function () {
                // console.log("ERROR");
                alert('Error opening new page. Try again or contact support')
            });
        }

        function savePage(reload) {
            var pdf_id = $('#pdfId').val();
            $.ajax({
                url: '/pdfs/save_page',
                type: 'PUT',
                data: {
                    authenticity_token: $('[name="csrf-token"]')[0].content,
                    page: universalPageCounter,
                    pdf_id: pdf_id
                },
                success: function () {
                    showFeedback(true);
                    if (reload === true) location.reload();
                }
            }).fail(function (response) {
                showFeedback(false);
                alert("Failed to save, please try again or contact the administrator");
            });
        }

        function showFeedback(value) {
            var icon = value ? 'success' : 'error';
            const Toast = Swal.mixin({
                toast: true,
                position: 'top-end',
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true
            })

            Toast.fire({
                icon: icon,
                width: 100
            })
        }

    }
</script>








